LAB_2

main()
{
    ...
    #pragma omp parallel{
        ...
    }
}

Модель fork join
Число потоков - переменная окружения

Способы задания числа потоков:
1)export OMP_NUM_THREADS=4
2)omp_set_num_threads(16)
3)#pragma omp parallel num_threads(8)

Сколько нитей будет в программе?
Чем ближе определение числа процессов к секции #pragma, тем оно приоритетнее

OpenMP зачасутю используется при распараллеливании циклов

int main(){
    #pragma omp parallel private(i)

    double sum = 0; //shared переменная
    #pragma omp for
    for(int i = 0; i < 100; i++){
        double priv_sum = 0;

        //#pragma omp atomic
        //sum += B[i];
    }
    //здесь делаем всего одно сложение вместо 100 в цикле
    #pragma omp atomic
    sum += priv_sum;
}

a)sum: ОП -> регистр
b)reg: +
c)sum: reg -> ОП

Нить А:             Нить В:
a)reg: 7            a)reg: 7     
b)reg: 7+5          b)reg: 7+8
c)ОП:12             c)ОП:15

Если нить А быстрее выполнила операции, то нить В перезатрет резлуьтат нити А
Использовать #pragma omp atomic: Все нити ждут, пока одна не закончит свои операции

atomic действует только на одну команду/оператор
#pragma omp critical
в critical секцию можно записать несколько команд


Reduction:
#pragma omp for / reduction(+ : S)
for(int i = 0; i < 100; i++){
    sum += B[i];
}
В reduction все делается автоматически





