Умножение матриц

A(n1 * n2)  B(n2 * n3)

A                   B
* * * * * *         * * * * * *
* * * * * *         * * * * * *
* * * * * *         * * * * * *
* * * * * *         * * * * * *
* * * * * *         * * * * * *
* * * * * *         * * * * * *

R(p1 * p2)
*  *  *
* |*| *

n1 кратно p1
n3 кратно p2

Все процессы верхней горизонтальной решетки обладают верхней половиной матрицы А

Все столбцы решетки процессов обладают по одной третьей части разделения матрицы В по столбцам

(0, 0) (0, 1) (0, 2)
(1, 0) (1, 1) (1, 2)

=====АЛГОРИТМ=====
1) (0, 0) gen(A, B)
2) (0, 0) Scatter(A)(С1) -> (0, 0) , (1, 0)
в Scatter используется коммуникатор (MPI_COMM_WORLD - все процессы)
Но нам нужны только процессы первого столбца
Создать свой коммуникатор
3) (0, 0) Bcast(A_part)(C4) -> (0, i), i = 0, 1, 2
   (1, 0) Bcast(A_part)(C5) -> (1, i), i = 0, 1, 2

Шаги 2, 3 аналогичны для матрицы В 

4) (0, 0) Scatter(B, (n2 * n3) / p2, MPI_DOUBLE, B_part, (n2 * n3) / p2, MPI_DOUBLE, ??root??, C4)
sendcounts, recvcounts - (n2 * n3) / p2
communicator - C4
root
Все процессы вразных коммуникаторах пронумерованы по разному!
Нужно узнать какой номер процесса (0, 0) в коммуникаторе C4!

Scatter разрещает матрицу по горизонтали!
Но нам нужно разрезать матрицу B по вертикали

Нужно исользовать производный тип данных MPI!!!

Произвдный тип данных - шаблон накладываемый на непрерывный кусок памяти
Неэффективно использовать Scatter
4)create type (for_B)
5)Если использовать Scatter, то вылезет неприятный моментик
    Использовать Send, Recv, но обязательно с производными типами
    (Можно отосалть необходмый кусок за одну посылку Send)
(0, 0) for (i = 1; i < p2; i++)
            send(B_part, ..., for_B, ..., C4) --> (0, i)
6)(0, i), i != 0
    Recv (B_part, ..., MPI_DOUBLE)
7) (0, i) Bcast(B_part) (Ci) --> (j, i), j = 0, ..., p1

8)A_part * B_part = C_part
Нужно собрать части матрицы С в одном процессе (0, 0)

Gather --> вылезет неприятный моментик
Использовать Send, Recv
9) (i, j) send (C_part, 6, ..., MPI_DOUBLE, ...) --> (0, 0)
10) Иcпользовать производный тип данных при приеме
    create type (for_C)
11)for(i, j)
    (0, 0) Recv (&C[m][k], 6, for_C, MPI_COMM_WORLD, ...)

Sp = T1/Tp 
T1 = время последовательной программы (тупое умножение матрицы А на B)



